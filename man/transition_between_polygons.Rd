% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transition-between-polygons.R
\name{transition_between_polygons}
\alias{transition_between_polygons}
\title{Transition between polygons}
\usage{
transition_between_polygons(
  start.polygon,
  end.polygon,
  time,
  vertex.order = "reorder"
)
}
\arguments{
\item{start.polygon, end.polygon}{Dataframes/matrices containing the vertices of the
polygons to interpolate between. The coordinates of the vertices must be stored in columns named "x" and "y",
and the polygons must contain the same number of vertices.}

\item{time}{The times at which we are interested in interpolating the polygons. \code{time = 0} gives
\code{start.polygon}, while \code{time = 1} gives \code{end.polygon}. Can be either a single number
or a numeric vector. If time contains values outside [0, 1], a warning will be given.}

\item{vertex.order}{Determines whether and how the vertices in \code{start.polygon} and \code{end.polygon}
are reordered before the interpolation is computed. If \code{vertex.order = "preserve"}, no
reordering is applied, and the polygons are used as-is. If \code{vertex.order = "reorder"},
the function first ensures that the polygons have the same orientation (i.e. clockwise/counter-clockwise).
Then, it attempts to shift the indices of the vertices so that the corresponding vertices on
\code{start.polygon} and \code{end.polygon} are "aligned".}
}
\value{
A data frame that contains one row per vertex. If \code{start.polygon}
and \code{end.polygon} contain n vertices, and \code{time} contains m values, then
the returned data frame will contain n*m rows. following columns:
\item{x, y}{The coordinates of the vertex}
\item{group}{Which polygon the vertex belongs to (1 for the first value in \code{time}, 2 for the second and so on)}
\item{time}{The time value of the associated polygon}
}
\description{
Function that interpolates/transitions between two polygons. This is done by
computing \code{(1 - time)*start.polygon + time*end.polygon}.
}
\note{
It is recommended to ensure that the start and end polygons have the correct
orientation and numbering of vertices before computing the transition, and then using
\code{vertex.order = "preserve"}.
}
\examples{
# Example: Transition from hexagon to square
# Create hexagon
hexagon.df = compute_regular_polygons(
  center = c(0, 0),
  radius = 1,
  rotation = 0,
  num.edges = 6
)
# Round corners slightly
hexagon.df = round_polygon_corners(hexagon.df, corner.radius.scale = 0.3)

# Create square
square.df = compute_regular_polygons(
  center = c(20, -20),
  radius = 2,
  rotation = 0,
  num.edges = 4
)
# Round corners slightly
square.df = round_polygon_corners(square.df, corner.radius.scale = 0.3)

# Resample polygons with many vertices, so that the transition becomes smooth
num.vertices = 1000
resample.time = seq(0, 1, length.out = num.vertices + 1)[-(num.vertices + 1)]
hexagon.resample = interpolate_polygon(hexagon.df)(resample.time)
square.resample = interpolate_polygon(square.df)(resample.time)

# Show transition over 10 steps
num.transition = 10
transition.time = seq(0, 1, length.out = num.transition)
# Use vertex.order = "preserve" (both polygons are CCW, and have the top vertex
# as the first in hexagon.df and square.df)
transition.df = transition_between_polygons(
  hexagon.resample,
  square.resample,
  transition.time,
  "preserve")

# Show the result:
library(ggplot2)
ggplot()+
  geom_polygon(data = transition.df, aes(x = x, y = y, group = group), fill = NA, color = "black")+
  coord_fixed()

}
\author{
Mathias Isaksen \email{mathiasleanderi@gmail.com}
}
